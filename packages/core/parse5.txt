// ============================================================================
// ENHANCED @joyboy/core PACKAGE - INTEGRATED WITH SOURCE REGISTRY
// ============================================================================

// ============================================================================
// FILE: packages/core/package.json (UPDATED)
// ============================================================================
{
  "name": "@joyboy/core",
  "version": "1.0.0",
  "type": "module",
  "description": "Core SDK and runtime for the JoyBoy parser ecosystem",
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js",
      "default": "./dist/index.js"
    }
  },
  "files": [
    "dist"
  ],
  "scripts": {
    "build": "tsup",
    "dev": "tsup --watch",
    "test": "vitest",
    "clean": "rm -rf dist"
  },
  "keywords": [
    "joyboy",
    "manga",
    "parser",
    "core",
    "sdk"
  ],
  "license": "MIT",
  "dependencies": {
    "@joyboy/types": "workspace:*",
    "@joyboy/source-registry": "workspace:*"
  },
  "devDependencies": {
    "tsup": "^8.0.1",
    "typescript": "^5.3.0",
    "vitest": "^1.0.0"
  },
  "peerDependencies": {
    "@joyboy/types": "^1.0.0",
    "@joyboy/source-registry": "^1.0.0"
  }
}

// ============================================================================
// FILE: packages/core/src/github-loader.ts (NEW)
// ============================================================================

// ============================================================================
// FILE: packages/core/src/runtime.ts (ENHANCED)
// ============================================================================
/**
 * Enhanced JoyBoy runtime with source registry integration
 */

import { SourceRegistry } from './registry';
import { GitHubSourceLoader } from './github-loader';
import type { Source } from './base-source';
import type { Manga } from '@joyboy/types';
import type { ProgressCallback } from './github-loader';

// Import from source-registry
import {
  createRegistry,
  syncRegistry as syncRemoteRegistry,
  getAllSources as getRegistrySources,
  getSourceById,
  searchSources as searchRegistrySources,
  markAsInstalled,
  getInstalledSources,
  getAvailableSources,
  type RegistryEntry,
  type UpdateInfo,
  type GitHubRegistryConfig
} from '@joyboy/source-registry';

/**
 * Main JoyBoy runtime class with integrated source registry
 */
export class JoyBoy {
  private static registry = SourceRegistry.getInstance();
  private static loader = new GitHubSourceLoader();
  private static remoteRegistryConfig: GitHubRegistryConfig | null = null;

  // ============================================================================
  // CONFIGURATION
  // ============================================================================

  /**
   * Configure remote GitHub registry
   * 
   * @param config - GitHub registry configuration
   * 
   * @example
   * ```typescript
   * JoyBoy.configureRegistry({
   *   owner: 'my-org',
   *   repo: 'my-sources',
   *   branch: 'main'
   * });
   * ```
   */
  static configureRegistry(config: GitHubRegistryConfig): void {
    this.remoteRegistryConfig = config;
  }

  // ============================================================================
  // REGISTRY OPERATIONS
  // ============================================================================

  /**
   * Sync with remote GitHub registry
   * 
   * @returns Promise that resolves when sync is complete
   * 
   * @example
   * ```typescript
   * await JoyBoy.syncRegistry();
   * const sources = JoyBoy.browseSources();
   * ```
   */
  static async syncRegistry(): Promise<void> {
    if (this.remoteRegistryConfig) {
      const catalog = createRegistry(this.remoteRegistryConfig);
      await catalog.sync();
    } else {
      await syncRemoteRegistry();
    }
  }

  /**
   * Browse available sources from registry
   * 
   * @returns Array of available sources
   * 
   * @example
   * ```typescript
   * const sources = JoyBoy.browseSources();
   * console.log(`Found ${sources.length} sources`);
   * ```
   */
  static browseSources(): RegistryEntry[] {
    return getRegistrySources();
  }

  /**
   * Search for sources in registry
   * 
   * @param query - Search query
   * @returns Matching sources
   * 
   * @example
   * ```typescript
   * const results = JoyBoy.searchSources('manga');
   * ```
   */
  static searchSources(query: string): RegistryEntry[] {
    return searchRegistrySources(query);
  }

  /**
   * Get source info from registry
   * 
   * @param sourceId - Source identifier
   * @returns Registry entry or undefined
   * 
   * @example
   * ```typescript
   * const info = JoyBoy.getSourceInfo('mangadex');
   * console.log(info?.name);
   * ```
   */
  static getSourceInfo(sourceId: string): RegistryEntry | undefined {
    return getSourceById(sourceId);
  }

  /**
   * Get all installed sources info
   * 
   * @returns Array of installed source info
   */
  static getInstalledSourcesInfo(): RegistryEntry[] {
    return getInstalledSources();
  }

  /**
   * Get all available (not installed) sources info
   * 
   * @returns Array of available source info
   */
  static getAvailableSourcesInfo(): RegistryEntry[] {
    return getAvailableSources();
  }

  // ============================================================================
  // SOURCE INSTALLATION & MANAGEMENT
  // ============================================================================

  /**
   * Install source from GitHub registry
   * 
   * @param sourceId - Source identifier from registry
   * @param onProgress - Optional progress callback
   * @returns Loaded source instance
   * 
   * @example
   * ```typescript
   * const source = await JoyBoy.installSource('mangadex', (progress, status) => {
   *   console.log(`${progress}%: ${status}`);
   * });
   * ```
   */
  static async installSource(
    sourceId: string,
    onProgress?: ProgressCallback
  ): Promise<Source> {
    const entry = getSourceById(sourceId);

    if (!entry) {
      throw new Error(`Source not found in registry: ${sourceId}`);
    }

    try {
      // Load source from GitHub
      const source = await this.loader.loadFromRegistry(entry, onProgress);

      // Register in local registry
      this.registry.register(source);

      // Mark as installed in remote registry
      markAsInstalled(sourceId, true);

      return source;
    } catch (error) {
      throw new Error(`Installation failed: ${(error as Error).message}`);
    }
  }

  /**
   * Uninstall a source
   * 
   * @param sourceId - Source identifier
   * 
   * @example
   * ```typescript
   * JoyBoy.uninstallSource('mangadex');
   * ```
   */
  static uninstallSource(sourceId: string): void {
    // Remove from local registry
    this.registry.unregister(sourceId);

    // Clear cache
    this.loader.clearCache(sourceId);

    // Mark as not installed
    markAsInstalled(sourceId, false);
  }

  /**
   * Reinstall/update a source
   * 
   * @param sourceId - Source identifier
   * @param onProgress - Optional progress callback
   * @returns Updated source instance
   * 
   * @example
   * ```typescript
   * const source = await JoyBoy.updateSource('mangadex');
   * ```
   */
  static async updateSource(
    sourceId: string,
    onProgress?: ProgressCallback
  ): Promise<Source> {
    // Clear cache first
    this.loader.clearCache(sourceId);

    // Uninstall current version
    this.uninstallSource(sourceId);

    // Install new version
    return this.installSource(sourceId, onProgress);
  }

  /**
   * Check for available updates
   * 
   * @returns Array of update information
   * 
   * @example
   * ```typescript
   * const updates = await JoyBoy.checkForUpdates();
   * updates.forEach(update => {
   *   console.log(`${update.sourceId}: ${update.currentVersion} -> ${update.newVersion}`);
   * });
   * ```
   */
  static async checkForUpdates(): Promise<UpdateInfo[]> {
    // Sync registry first
    await this.syncRegistry();

    // Get installed sources
    const installed = this.registry.list();
    const installedMap = new Map(
      installed.map(s => [s.id, s.version])
    );

    // Get available updates from registry
    const { GitHubRegistry, DEFAULT_GITHUB_CONFIG } = await import('@joyboy/source-registry');
    const githubRegistry = new GitHubRegistry(
      this.remoteRegistryConfig || DEFAULT_GITHUB_CONFIG
    );

    return githubRegistry.checkUpdates(installedMap);
  }

  /**
   * Install all available updates
   * 
   * @param onProgress - Optional progress callback (receives sourceId and progress)
   * 
   * @example
   * ```typescript
   * await JoyBoy.updateAll((sourceId, progress, status) => {
   *   console.log(`${sourceId}: ${progress}% - ${status}`);
   * });
   * ```
   */
  static async updateAll(
    onProgress?: (sourceId: string, progress: number, status: string) => void
  ): Promise<void> {
    const updates = await this.checkForUpdates();

    for (const update of updates) {
      try {
        await this.updateSource(update.sourceId, (progress, status) => {
          onProgress?.(update.sourceId, progress, status);
        });
      } catch (error) {
        console.error(`Failed to update ${update.sourceId}:`, error);
      }
    }
  }

  // ============================================================================
  // DIRECT SOURCE LOADING (Existing Methods)
  // ============================================================================

  /**
   * Load source directly (for development/testing)
   * 
   * @param source - Source instance, package name, or lazy loader
   * @returns Loaded source instance
   * 
   * @example
   * ```typescript
   * // From instance
   * await JoyBoy.loadSource(new MangaDexSource());
   * 
   * // From package (if published to NPM)
   * await JoyBoy.loadSource('@joyboy/source-mangadex');
   * 
   * // From lazy loader
   * await JoyBoy.loadSource(() => import('@joyboy/source-mangadex'));
   * ```
   */
  static async loadSource(
    source: Source | string | (() => Promise<any>)
  ): Promise<Source> {
    try {
      let sourceInstance: Source;

      if (typeof source === 'string') {
        // Dynamic import from package name
        const module = await import(/* @vite-ignore */ source);
        const SourceClass = module.default;

        if (!SourceClass) {
          throw new Error(`No default export found in ${source}`);
        }

        sourceInstance = new SourceClass();
      } else if (typeof source === 'function') {
        // Lazy loader function
        const module = await source();
        const SourceClass = module.default;
        sourceInstance = new SourceClass();
      } else {
        // Direct instance
        sourceInstance = source;
      }

      // Validate and register
      this.validateSource(sourceInstance);
      this.registry.register(sourceInstance);

      return sourceInstance;
    } catch (error) {
      throw new Error(`Failed to load source: ${(error as Error).message}`);
    }
  }

  // ============================================================================
  // SOURCE ACCESS
  // ============================================================================

  /**
   * Get a loaded source by ID
   * 
   * @param id - Source identifier
   * @returns Source instance
   * @throws Error if source is not loaded
   * 
   * @example
   * ```typescript
   * const mangadex = JoyBoy.getSource('mangadex');
   * const results = await mangadex.search('One Piece');
   * ```
   */
  static getSource(id: string): Source {
    const source = this.registry.get(id);

    if (!source) {
      const available = this.registry.list().map(s => s.id).join(', ');
      throw new Error(
        `Source '${id}' is not loaded. Available sources: ${available || 'none'}`
      );
    }

    return source;
  }

  /**
   * List all loaded sources
   * 
   * @returns Array of loaded source instances
   * 
   * @example
   * ```typescript
   * const sources = JoyBoy.listSources();
   * sources.forEach(source => {
   *   console.log(`${source.name} (${source.id})`);
   * });
   * ```
   */
  static listSources(): Source[] {
    return this.registry.list();
  }

  /**
   * Check if a source is loaded
   * 
   * @param id - Source identifier
   * @returns True if loaded
   * 
   * @example
   * ```typescript
   * if (JoyBoy.hasSource('mangadex')) {
   *   const source = JoyBoy.getSource('mangadex');
   * }
   * ```
   */
  static hasSource(id: string): boolean {
    return this.registry.has(id);
  }

  /**
   * Unload a source (without uninstalling)
   * 
   * @param id - Source identifier
   * @returns True if unloaded
   */
  static unloadSource(id: string): boolean {
    return this.registry.unregister(id);
  }

  /**
   * Clear all loaded sources
   */
  static clearSources(): void {
    this.registry.clear();
  }

  // ============================================================================
  // MULTI-SOURCE OPERATIONS
  // ============================================================================

  /**
   * Search across multiple sources
   * 
   * @param query - Search query
   * @param sourceIds - Optional array of source IDs (default: all loaded)
   * @returns Map of source ID to results
   * 
   * @example
   * ```typescript
   * const results = await JoyBoy.searchAll('One Piece');
   * 
   * for (const [sourceId, manga] of results) {
   *   console.log(`${sourceId}: ${manga.length} results`);
   * }
   * ```
   */
  static async searchAll(
    query: string,
    sourceIds?: string[]
  ): Promise<Map<string, Manga[]>> {
    const sources = sourceIds
      ? sourceIds.map(id => this.getSource(id))
      : this.registry.list().filter(s => s.search);

    const results = await Promise.allSettled(
      sources.map(async source => {
        if (source.search) {
          const items = await source.search(query);
          return { sourceId: source.id, items };
        }
        return { sourceId: source.id, items: [] };
      })
    );

    const resultMap = new Map<string, Manga[]>();

    results.forEach(result => {
      if (result.status === 'fulfilled') {
        resultMap.set(result.value.sourceId, result.value.items);
      }
    });

    return resultMap;
  }

  // ============================================================================
  // VALIDATION
  // ============================================================================

  /**
   * Validate source instance
   */
  private static validateSource(source: any): asserts source is Source {
    const required = ['id', 'name', 'version', 'baseUrl', 'getMangaDetails', 'getChapters', 'getChapterPages'];

    for (const prop of required) {
      if (!(prop in source)) {
        throw new Error(`Source validation failed: missing required property '${prop}'`);
      }
    }

    if (typeof source.getMangaDetails !== 'function') {
      throw new Error('Source validation failed: getMangaDetails must be a function');
    }

    if (typeof source.getChapters !== 'function') {
      throw new Error('Source validation failed: getChapters must be a function');
    }

    if (typeof source.getChapterPages !== 'function') {
      throw new Error('Source validation failed: getChapterPages must be a function');
    }
  }
}

// ============================================================================
// FILE: packages/core/src/index.ts (UPDATED)
// ============================================================================
/**
 * @joyboy/core
 * Core SDK and runtime for the JoyBoy parser ecosystem
 * Integrated with GitHub-based source registry
 */

// Export main runtime
export { JoyBoy } from './runtime';

// Export base classes
export { BaseSource } from './base-source';
export type { Source } from './base-source';

// Export registry
export { SourceRegistry } from './registry';

// Export utilities
export { RequestManager } from './utils/request';
export { CacheManager } from './utils/cache';
export { isSourceError, formatError, isRetryableError } from './utils/errors';

// Export GitHub loader
export { GitHubSourceLoader } from './github-loader';
export type { ProgressCallback } from './github-loader';

// Re-export types from @joyboy/types
export type {
  Manga,
  Chapter,
  Page,
  SourceInfo,
  SourceCapabilities,
  SearchOptions,
  RequestOptions,
  SourceError,
  MangaStatus,
  ContentRating
} from '@joyboy/types';

export { ErrorType, createSourceError } from '@joyboy/types';

// Re-export registry types for convenience
export type {
  RegistryEntry,
  UpdateInfo,
  RegistryStats,
  GitHubRegistryConfig
} from '@joyboy/source-registry';

// ============================================================================
// USAGE EXAMPLES
// ============================================================================

/*
// =============================================================================
// EXAMPLE 1: Basic Usage with Registry
// =============================================================================

import { JoyBoy } from '@joyboy/core';

async function basicExample() {
  // 1. Sync with remote registry
  await JoyBoy.syncRegistry();
  
  // 2. Browse available sources
  const sources = JoyBoy.browseSources();
  console.log(`Found ${sources.length} sources`);
  
  // 3. Install a source
  await JoyBoy.installSource('mangadex', (progress, status) => {
    console.log(`${progress}%: ${status}`);
  });
  
  // 4. Use the source
  const mangadex = JoyBoy.getSource('mangadex');
  const results = await mangadex.search('One Piece');
  
  console.log(`Found ${results.length} results`);
}

// =============================================================================
// EXAMPLE 2: React Native App
// =============================================================================

import React, { useState, useEffect } from 'react';
import { View, Text, FlatList, Button, ActivityIndicator } from 'react-native';
import { JoyBoy } from '@joyboy/core';

function SourceManagerScreen() {
  const [sources, setSources] = useState([]);
  const [loading, setLoading] = useState(true);
  const [installing, setInstalling] = useState(null);
  const [progress, setProgress] = useState({ percent: 0, status: '' });

  useEffect(() => {
    loadSources();
  }, []);

  async function loadSources() {
    try {
      // Sync with GitHub registry
      await JoyBoy.syncRegistry();
      
      // Get all sources
      const available = JoyBoy.browseSources();
      const installed = JoyBoy.listSources().map(s => s.id);
      
      setSources(available.map(s => ({
        ...s,
        isInstalled: installed.includes(s.id)
      })));
    } catch (error) {
      console.error('Failed to load sources:', error);
    } finally {
      setLoading(false);
    }
  }

  async function installSource(sourceId) {
    setInstalling(sourceId);
    
    try {
      await JoyBoy.installSource(sourceId, (percent, status) => {
        setProgress({ percent, status });
      });
      
      await loadSources();
      alert('Source installed successfully!');
    } catch (error) {
      alert(`Installation failed: ${error.message}`);
    } finally {
      setInstalling(null);
      setProgress({ percent: 0, status: '' });
    }
  }

  async function uninstallSource(sourceId) {
    try {
      JoyBoy.uninstallSource(sourceId);
      await loadSources();
      alert('Source uninstalled');
    } catch (error) {
      alert(`Uninstall failed: ${error.message}`);
    }
  }

  if (loading) {
    return <ActivityIndicator size="large" />;
  }

  return (
    <View style={{ flex: 1, padding: 16 }}>
      <Text style={{ fontSize: 24, fontWeight: 'bold', marginBottom: 16 }}>
        Source Manager
      </Text>

      {installing && (
        <View style={{ padding: 16, backgroundColor: '#f0f0f0', marginBottom: 16 }}>
          <Text>Installing {installing}...</Text>
          <Text>{progress.status}</Text>
          <View style={{ width: '100%', height: 4, backgroundColor: '#ddd', marginTop: 8 }}>
            <View style={{ width: `${progress.percent}%`, height: '100%', backgroundColor: '#2196f3' }} />
          </View>
        </View>
      )}

      <FlatList
        data={sources}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => (
          <View style={{ padding: 16, marginBottom: 12, backgroundColor: '#f5f5f5' }}>
            <Text style={{ fontSize: 18, fontWeight: 'bold' }}>{item.name}</Text>
            <Text style={{ color